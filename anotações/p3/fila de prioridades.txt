Fila de prioridades
    é uma TAD
    comportamento de fila porem o primeiro elemento é o que tem maior prioridade em uma fila

    para grande volume de dados sem a necessidade da ordenação de tudo, o foco é na prioridade de determinado elemento
    prioridade maxima
        maior chave, maior prioridade
    prioridade mínima
        menor chave, maior prioridade

    vetores e listas encadeadas
        não ordenado
            selecionar o de maior prioridade e colocar no inicio (selection_sort)
        ordenado
            a cada novo item, posicionar comparando com seus antecessores (insertion_sort)
    heap binária 
        arvore binaria completa
            todos os niveis exceto o ultimo estao cheios
            nós do último nível estão mais a esquerda possível
            raiz: chave de maior prioridade
            não ordena por completo
                mais próximo da raiz, maior prioridade
                filhos com valores menores ou iguais
            representada por vetor
                representação sequencial
                acesso direto
                níveis por índices
            navegação para cima e baixo
                nó: k
                pai: k/2
                filhos: 2k e 2k+1
            tamanho N em um vetor pq[]
                pq[N+1]:pq[1...N]
                não usa pq[0]
                pai: (k-1)/2
                filhos 2k+1 e 2k+2
            interface(manipulação da fila)
                PQinit(int maxN)
                    criar fila com capacidade máxima inicial
                PQempty()
                    testar se esta vazia
                PQinsert(Item v)
                    inserir elemento
                PQdelmax()
                    retornar e remover(maior prioridade)
            >inserção
                insere ns folhas(no fim do vetor)
                restaura/conserta subindo na heap(buttom-up/swim-fixUp)
                    flutua a chave maior que o pai, recursivamente, ate um pai maior ou raiz
                complexidade: 1+logN comparações O(logN)
            >remoção
                substitui a raiz por uma folhas
                restaura/conserta descendo na heap(top-down/sink-fixDown)
                    afunda a chave menor, recursivamente afunda a chave ate que os filhos sejam menores
                complexidade: 2logN comparações
            >alterar prioridade
                se tem o índice na fila de prioridades:
                    void PQchange(int k, int valor)
                sem acesso direto:
                    lista de índices
        heap sort
            filas de prioridades para ordenar elementos
                construção da heap-ordenada
                    topo=maior prioridade
                    não há garantia de completa ordenação
                    construção da heap por inserção
                        varredura da esquerda para direita
                        fixUp para posicionar na heap
                        custo proporcional a 2 ∗ N ∗ log N
                ordenação por remoção
                    ordenação por remoção (maior prioridade)
                        reorganização da fila de prioridades
                        cada item removido volta para o vetor original
                in-place
                    sim
                estável
                    não
                adaptativo
                    não
        intro sort
            combinação de algoritmos para utilizar as eficiências e evitar as deficiÊncias dos métodos
            complexidade
                pior caso: O(n*logn)
            in-place
                sim
            estável
                não
            adaptativo
                não