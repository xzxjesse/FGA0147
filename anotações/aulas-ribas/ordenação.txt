Algoritmos de Ordenação
Prof. Bruno Ribas
https://www.youtube.com/playlist?list=PLzZut2slkqywtFxqTY8AQwIG65h_2oMBL


in-place
    cabe na memória
estável
    garante que itens com chaves identicas permaneçam na mesma posição relativa no vetor/conjunto de dados


>selection sort
    deve percorrer o vetor, selecionar o menor e posicionar ele no menor indice, vai incrementando ate finalizar o vetor
    instável
    in-place

>bubble sort
    deve percorrer o vetor, flutuar menor e afundar o maior a cada passada
    estável
    in-place

    sempre se comportara mal, não percebe que o vetor está ordenado

>insertion sort
    parte de um elemento do vetor e compara o elemento com seus adjacentes para posiciona-lo
    estável
    in-place

>shell sort
    mesma ideia do insertion sort, entre tanto, ao inves de comparar so com os adjacentes, o intervalo de comparação é maior
    instável
    in-place

    desempenho bom, mas dificil calcular a complexidade

>quick sort
    separar e rearranjar o vetor, escolhe um elemento e todos os maiores devem estar a direita e os menores a esquerda do elemento, mesmo que os subvetores não estejam ordenados
    {5 3 4 (6) 9 7 8}
    instável
    in-place

    >mediana de três
    melhora o desempenho, faz boa escolha do pivo (mais proximo da mediana do vetor)


>merge sort
    dividir no meio e ordenar cada metade, divide a quantidade necessaria pra facilitar a ordenação (valores unitários)
    instável
    não in-place


desempenho
    o comportamento dos algortmos é usado para definir a eficiência dele
    complexidade
        tempo de execução -> eficiência do algoritmos
        espaço ocupado -> eficiência da estrutura de dados
    medida
        função custo ou comlexidade f(n)
        calculado para:
            melhor caso (menor tempo de execução)
                f(n)=1
            pior caso (maior tempo de execução)
                f(n)=n
            caso médio (média dos tempos de execução)
                f(n)=(n+1)/2
    complexidade assintótica
        calculo aproximado da eficiência do algoritmo
        notação O
            f(n)=n^2+2n+1 -> O(n^2)
            pega o maior expoente de n e exclui as constantes
        é comparada a tendência de crescimento de f(n) e g(n)
        f(n)=O(1)
            complexidade constante
            número fixo de execuções
        f(n)=O(n)
            complexidade linear
            vetor
        f(n)=O(logn)
            complexidade logarítmica
            busca binária
        f(n)=O(nlogn)
            complexidade logarítmica
            merge_sort
        f(n)=O(n^2)
            complexidade quadrática
            bubble_sort
        f(n)=O(n^3)
            complexidade cúbica
            multiplicação de matrizes
        f(n)=O(2^n)
            complexidade exponencial
        f(n)=O(n!)
            complexidade fatorial