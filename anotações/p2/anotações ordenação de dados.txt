ordenação/organização de dados
    otimiza as buscas
        logica: sequencialmente estruturadas, gera previsibilidade
    itens (arquivos, pastas)
        chave: parte do item que é usada como parâmetro

algoritmos de ordenação

-caracteristicas
    complexidade (espacial, temporal)
        quadráticos: simples e suficientes
        linearitmicos: mais complexos e eficientes
    estabilidade
        mantem a ordem/posição relativa dos elementos
    adaptatividade
        aproveitamento da ordenação pré-existente
    memória extra
        in-place: utiliza a própria estrutura, sem memória extra significativa
        não in-place: utiliza memória e estrutura externa (copias)
    localização
        interna: cabe na ram (memória principal)
        externa: usa memória secundária, ordenada por pedaços (chunks)

-elementares x eficientes
    elementares: custos maiores, mais simples
    eficientes: custos menores, mais complexos
    analisar a função custo e o tamanho da entrada
    array x listas encadeadas
        metodos elementares: lidam bem com todas as implementações
        metodos eficientes: 
            array acesso direto
            estruturas encadeadas: arvores ordenadas

ELEMENTARES
selection sort
    selecionar e posicionar
    selecionar o menor item e posicionar na posição definitiva, faz isso até percorrer o vetor todo

    complexidade assintótica 
        O(N^2)
    adaptatividade
        não
    estabilidade
        não, tem trocas com saltos
    in-place
        sim, sem uso de memorias extra significativa nem copias

    é possível fazer de modo estável 
        sem swap
    é possível fazer com listas encadeadas
        são sequenciais

bubble sort
    flutue o maiores
    flutuar os elementos do inicio e trocando pelos maiores para que fiquem no topo(fim), comparado com o adjacente

    função custo: (n^2)/2+(n^2)2

    complexidade assintótica
        O(N^2), quadrática
        melhor caso: O(N)
    adaptatividade
        sim, a ordenação diminui o processamento
    estabilidade
        sim, só faz com elementos adjacentes
    in-place
        sim, sem copias ou memoria externa

    o bubble faz mais swaps que o selection sort então não é tão eficiente
    bubble pode ser feito com lista encadeada, pois são sequenciais
    shaker sort é mais otimizado (flutua o maior e afoga o menor)

insert sort
    inserir na posição adequada de acordo com a comparação com os anteriores
        percorre a partir do segundo elemento
        compara com o antecessor
        insere quando necessario
        recomeça
    
    complexidade assintotica
        O(n^2)
        pior caso
            N^2/2
        caso médio
            N^2/4
        melhor caso
            O(N)
    adaptavel
        sim, ele aproveita a ordenação pré existente
    estável
        sim, não há trocas com saltos e mantem a ordem pois não troca os iguais
    in-place
        sim, não usa memoria significativa nem copia estrutura

    não é indicado para grande estradas desordenadas ou invertidas
    mesmo desempenho do bubble
    troca só com adjacentes

shell sort
    extensão do insertion sort

    ordena parcialmente a cada passagem e depois usa o insertion para ordenar

    complexidade assintotica
        melhor caso
            entre O(n) e O(n^2), dependendo da sequência utilizada
        caso medio
            sem conhecimento
        pior caso 
            O(nlogn)
    adaptativo
        sim
    estavel
        não
    in-place
        sim


EFICIENTES
merge sort
    dividir em pequenas partes
    ordenar
    juntar

    >top-down:
    lista inteira, dividir em sub-listas e ir subindo
    quando os subvetores estiverem em tamanho unitário, voltar fazendo o merge

    >bottoom-up: merge desde os vetores unitários
    para listas encadeadas é bom

    complexidade assintótica
        O(nlogn) - todos os casos
    adaptativo
        não
    estavel
        sim, mantem a ordem relativa
    in-place
        não, usa memória extra proporcional a n
    
    otimizações possíveis:
        nos subvetores pequenos, usar o insertion sort
        testar se o vetor está ordenado
        não usar um vetor auxiliar na função merge

Top-Down (Recursivo):
    Vantagens
        Facilidade de Implementação
        Estrutura Clara
    Desvantagens
        Estouro de Pilha
        Overhead de Chamadas de Função

Bottom-Up (Iterativo):
    Vantagens
        Menos Overhead de Chamadas de Função
        Uso Eficiente de Memória
    Desvantagens
        Menos Intuitivo
        
quick sort
    simples, eficiente, embasado, comprovado...

    dividir e conquistar
    ordena elemento por elemento

    separa os elementos baseado em 1 elemento
    conquista um elemento ordenado e dois sub vetores pseudo ordenado
    divide e repete para os subvetores

    particionamento: 
        escolher o elemento pivô
        referencia para reorganizar os elemento
        define a posição final dele
    repete o processamento

    condições
        nenhum elemento anterior que o pivo é menor e nenhum posterior sera maior
        (sub vetores ainda nao ordenados)

    -pivô: mais a direita do vetor, rearranja todos os outros

    complexidade assintotica
        melhor e médio:
            O(nlogn)
        pior:
            (n^2)/2
    adaptativo
        não, a ordenação não ajuda no desempenho
    estavel
        não, tem trocas com salto e não mantem a ordem relativa
    in-place
        sim, só usa a recursão (que é proporcional a log n)

    >mediana de 3
    pivo
        usar a mediana de uma pequena amostra de itens
        se for mais a direita:
            menor para L
            mediana para R
    melhora o particionamento

    bom para entradas aleatorias
    melhorias:
        usar o insertion sort para pequenos vetores
        particionar o vetor em 3 partes
            v[l..i]: elementos menores que o pivô
            v[i+1..j-1]: elementos iguais ao pivô
            v[j..r]: elementos maiores que o pivô